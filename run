#!/usr/bin/env bash

# MIT License
#
# Copyright (c) 2022 Jan Heuermann, https://www.jotaen.net
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# Runtime configuration.
# These variables can be overriden while parsing the flags.
TASK_FILE='./run.sh'
IS_VERBOSE='false'
ACTION=(action_list)

# Regex patterns for parsing the task file.
COMMENT_PATTERN='^#{1,}[[:blank:]]?(.*)$'
TASK_DEF_PATTERN_1='^[[:blank:]]*run_([a-zA-Z0-9_]+)[[:blank:]]*\([[:blank:]]*\)'
TASK_DEF_PATTERN_2='^[[:blank:]]*function[[:blank:]]*run_([a-zA-Z0-9_]+)'

# The --help procedure.
action_help() {
	echo 'Run tasks from a run.sh file.'
	echo
	echo 'Usage: run [OPTION] TASK [INPUT...]'
	echo
	echo 'Options:'
	echo '  -f, --file       Specify the task file (default: ./run.sh)'
	echo '  -h, --help       Print this help'
	echo '  -i, --info task  Show task description'
	echo '  -l, --list       List all available tasks'
	echo '  -v, --verbose    Print task command before executing'
	echo '      --version    Print version of this command'
}

# The --version procedure.
action_version() {
	echo 'Version 1.0-rc1'
}

# The --list procedure.
action_list() {
	local title_candidate=""
	local tasks=() # All encountered task names.
	local titles=() # All encountered titles. (Same arity as $tasks.)
	local longest_task_name=0 # Needed for aligning the output.

	# Parse the task file.
	while IFS= read -r line; do
		# Process comment block.
		if [[ "${line}" =~ $COMMENT_PATTERN ]]; then
			if [[ -z "${title_candidate}" ]]; then
				local comment_text="${BASH_REMATCH[1]}"
				title_candidate="${comment_text}"
			fi
			continue
		fi

		# After a comment block, there must be the task definition.
		# Allow both definition styles: `run_foo() {...` and `function run_foo {`.
		if [[ "${line}" =~ $TASK_DEF_PATTERN_1 || "${line}" =~ $TASK_DEF_PATTERN_2 ]]; then
			local task="${BASH_REMATCH[1]}"
			tasks+=("${task}")
			titles+=("${title_candidate}")
			if [[ ${#task} -gt $longest_task_name ]]; then
				longest_task_name=${#task}
			fi
		fi

		# Reset parser for next iteration.
		title_candidate=""
	done < "${TASK_FILE}"

	# Print out the gathered information.
	local column_offset=3
	for (( i=0; i<${#tasks[@]}; i++ )); do
		local padding=0
		if [[ "${titles[$i]}" != "" ]]; then
			padding=$((longest_task_name+column_offset))
		fi
		printf "%-${padding}s%s\n" "${tasks[$i]}" "${titles[$i]}"
	done
}

# The --info procedure.
action_info() {
	local requested_task="$1"
	local comment_block_candidate=() # All comment lines for the task.

	# Abort if no task name was specified.
	if [[ "${requested_task}" == '' ]]; then
		echo 'No task specified' >&2
		exit 1
	fi

	# Parse the task file.
	while IFS= read -r line; do
		if [[ "${line}" =~ $COMMENT_PATTERN ]]; then
			comment_block_candidate+=("${BASH_REMATCH[1]}")
			continue
		fi
		if [[ "${line}" =~ $TASK_DEF_PATTERN_1 || "${line}" =~ $TASK_DEF_PATTERN_2 ]]; then
			if [[ "${BASH_REMATCH[1]}" == "${requested_task}" ]]; then
				# Print out the gathered comment lines.
				for i in "${comment_block_candidate[@]}"; do
					echo "${i}"
				done
				exit
			fi
		fi
		comment_block_candidate=()
	done < "${TASK_FILE}"
	echo "No such task: ${requested_task}" >&2
	exit 1
}

# The procedure when invoking a task.
action_execute() {
	# Preserve all needed parameters before the cleanup.
	# The fancy prefix is necessary because these variables
	# are also visible within the task script.
	readonly _____run_task_name="$1"
	readonly _____run_task_identifier="run_${_____run_task_name}"
	readonly _____run_input=( "${@:2}" )
	readonly _____run_is_verbose="${IS_VERBOSE}"
	readonly _____run_task_file="${TASK_FILE}"

	# Clean up environment, to not pollute the task file.
	unset -f action_help
	unset -f action_info
	unset -f action_list
	unset -f action_version
	unset -f action_execute
	unset TASK_FILE
	unset IS_VERBOSE
	unset ACTION
	unset COMMENT_PATTERN
	unset TASK_DEF_PATTERN_1
	unset TASK_DEF_PATTERN_2
	set -- # Reset input arguments ($1, $2, ...)

	# Load “run” file with task definitions.
	# shellcheck source=./run.sh
	source "${_____run_task_file}"

	# Check that subcommand is defined.
	if [[ "$(type -t "${_____run_task_identifier}")" != 'function' ]]; then
		echo "No such task: ${_____run_task_name}" >&2
		exit 1
	fi

	# If requested, activate verbose mode.
	if "${_____run_is_verbose}"; then
		set -o xtrace
	fi

	# Invoke subcommand and pass all additional arguments.
	"${_____run_task_identifier}" "${_____run_input[@]}"
}

# Parse CLI arguments.
while [[ $# -gt 0 ]]; do
	case $1 in
		--help|-h)
			action_help
			exit
			;;
		--version)
			action_version
			exit
			;;
		--list|--ls|-l)
			ACTION=( action_list )
			shift
			continue
			;;
		--info=*|-i=*)
			ACTION=( action_info "${1#*=}" )
			shift
			continue
			;;
		--info|-i)
			ACTION=( action_info "$2" )
			shift
			shift
			continue
			;;
		--file=*|-f=*)
			TASK_FILE="${1#*=}"
			shift
			continue
			;;
		--file|-f)
			TASK_FILE="$2"
			shift
			shift
			continue
			;;
		--verbose|-v)
			IS_VERBOSE='true'
			shift
			continue
			;;
		-*)
			echo "Unknown option $1" >&2
			exit 1
			;;
		*)
			ACTION=( action_execute "$1" "${@:2}" )
			break
			;;
	esac
done

# If task file is given, check it.
if [[ -n "${TASK_FILE}" ]]; then
	# Check that it’s a regular file.
	if [[ -d "${TASK_FILE}" ]]; then
		echo "Not a file: ${TASK_FILE}" >&2
		exit 2
	fi
	# Check that it exists.
	if [[ ! -f "${TASK_FILE}" ]]; then
		echo "No such file: ${TASK_FILE}" >&2
		exit 2
	fi
	# Check that it’s executable.
	if [[ ! -x "${TASK_FILE}" ]]; then
		echo "File not executable: ${TASK_FILE}" >&2
		exit 2
	fi
fi

# Execute action.
"${ACTION[@]}"
